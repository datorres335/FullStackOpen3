Part 1 Introduction to React____________________________________________________________________________________________________________________________

npm create vite@latest 
	// to create a new React frontend project

//IMPORTANT!! When cloning an external project inside of an existing project, make sure to go inside of the newly cloned repo and delete the 	existing .git file with the commands:
		git clone <new project>
		cd <new project>
		rm -rf .git // MUST REMOVE .git FILE WHEN CLONING INTO EXISITNG PROJECT!!! 
		npm install
		"npm start" or "npm run dev"

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 2 Communicating with server________________________________________________________________________________________________________________________

npx json-server --port 3001 db.json 
	//runs a local fake REST API on port 3001 using data from db.json, need to have db.json implemented
npm install json-server --save-dev
	// to start the json server, add this script to package.json
		- "server": "json-server -p 3001 db.json"
	// then you run the server with the command:
		- npm run server

npm install axios 
	//Axios is a library that simplifies making HTTP requests and handling responses in JavaScript applications. Used mostly in frontend

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 3 Programming a server with NodeJS and Express ____________________________________________________________________________________________________

npm init
	// creates a package.json file, which defines your project and enables npm to manage dependencies and scripts.

npm install express 
	// for backend server

npm update
	// updates the dependencies of a project

npm install
	// Likewise, if we start working on the project on another computer, we can install all up-to-date dependencies of the project defined in 	package.json by running this command in the project's root directory

node --watch index.js
	// runs your Express server and automatically restarts it whenever your code changes
	// typically found as a script -> "dev": "node --watch index.js"
	// Does not: Hot-reload without restart, preserve server state, replace frontend hot module reload
	// although the server restarts automatically, you still need to refresh the browser

*.rest
	// once you have the plugin "REST client" installed, you can create .rest files to test out HTTP requests in the backend
		// ex: GET http://localhost:3001/api/notes
	// .rest files are typically placed in a "requsts" directory in the root folder

npm install cors
	// We can allow requests from other origins by using Node's cors middleware in the backend
	// even with proxy in place, you still want cors for production builds

// creating a proxy for the frontend in vite.config.js when in dev mode 
	// example:
		export default defineConfig({
		  plugins: [react()],
		  server: {
		    proxy: {
		      '/api': {
		        target: 'http://localhost:3003',
		        changeOrigin: true
		      }
		    }
		  }
		})

npm run build 
	// to create a production build of your application (used in the frontend with vite)

// useful custom scripts for backend: (SIDE NOTE: you sure that these scripts will work in PowerShell?????)
    "build:ui": "rm -rf dist && cd ../frontend && npm run build && cp -r dist ../backend",
    "deploy:full": "npm run build:ui && git add . && git commit -m uibuild && git push",

npm install mongoose 
	// install in the backend

npm install eslint @eslint/js --save-dev
	// analyzes your JavaScript for bugs and bad patterns, and @eslint/js provides a set of recommended rules, both used only during development.
npx eslint --init
	// to initialize a default ESlint configuration
npm install --save-dev @stylistic/eslint-plugin
	// to create formatting rules so you can enforce consistent code style without affecting program behavior (did not implement in project)
npx eslint index.js (CREATE CUSTOM SCRIPT TO USE)
	// to inspect and validate a file
	// recommended to create a custom script for it:
		// "lint": "eslint ."
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 4 Testing Express servers, user administration_____________________________________________________________________________________________________

npm install cross-env
	// lets you define environment variables in npm scripts in a way that works on all operating systems.
	// This is so that we can set "NODE_ENV" to different modes in the scripts
	// Example:
		"scripts": {
			"test": "cross-env NODE_ENV=test node --test",
			"start": "cross-env NODE_ENV=production node index.js",
			"dev": "cross-env NODE_ENV=development node --watch index.js" }
	// NODE_ENV lets your app and tools know whether they‚Äôre running in development, testing, or production so they can change behavior safely and 	efficiently.

npm install --save-dev supertest
	// a library for testing HTTP APIs (especially Express apps) without starting a real server.
	// Think of Supertest as Postman, but inside your test file and fully automated.

npm test -- tests/blog_api.test.js
	// executes tests specified by route argument

npm test -- --test-only
	// only the only marked tests are executed
	// Example:
		test.only('all notes are returned', async () => {
	// IMPORTANT NOTE!
	// IN ORDER FOR THIS COMMAND TO WORK YOU MUST INCLUDE "cross-env NODE_ENV=test"
	// BETTER YET, CREATE A CUSTOM SCRIPT TO RUN IT:
		"test:only": "cross-env NODE_ENV=test node --test --test-only"

npm test -- --test-name-pattern="a specific note is within the returned notes" // COMMAND DOES NOT WORK AS INTENDED!!!!!
	// COMMAND DOES NOT WORK AS INTENDED!!!!!
	// run tests with a specific name
	// The provided argument can refer to the name of the test or the describe block
	//It can also contain just a part of the name. The following command will run all of the tests that contain notes in their name:
		npm run test -- --test-name-pattern="notes"
	// COMMAND DOES NOT WORK AS INTENDED!!!!!
	// IMPORTANT NOTE!
	// IN ORDER FOR THIS COMMAND TO WORK YOU MUST INCLUDE "cross-env NODE_ENV=test"
	// BETTER YET, CREATE A CUSTOM SCRIPT TO RUN IT:
		"test:pattern": "cross-env NODE_ENV=test node --test --test-name-pattern"
	// THEN RUN: 
		npm run test:pattern "a specific blog can be viewed"

npm install bcrypt
	// a library used to securely hash passwords before storing them in a database
	// Never use bcrypt in the frontend

npm install jsonwebtoken
	//(often called JWT) lets your backend server issue & verify signed tokens so users stay authenticated without sending passwords on every request
	// Important: JWT payload is readable, so never store passwords or secrets in it.

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 5 Testing React apps_______________________________________________________________________________________________________________________________

npm install --save-dev vitest jsdom
	// Vitest runs tests (Provides test utilities: test, it, describe, expect)
	// jsdom pretends to be the browser (Simulates: window, document, HTMLElement, events, localStorage)
	// Together ‚Üí test React in Node
	// add this custom script:
		"test": "vitest run" 

npm install --save-dev @testing-library/react @testing-library/jest-dom
	// @testing-library/react ‚Äî render & interact with React components
		// Renders React components into a DOM (via jsdom)
		// Lets you query the UI the way a user would:
			text on the screen
			labels
			roles (buttons, headings, inputs)
		// Simulates user interactions
		// example:
			test('renders app title', () => {
			  render(<App />)
		  expect(screen.getByText('Blog list')).toBeInTheDocument()
			})
	// @testing-library/jest-dom ‚Äî better assertions for the DOM 
		// examples:
			expect(button).toBeInTheDocument()
			expect(button).toBeDisabled()
			expect(button).toHaveTextContent('Save')

npm install --save-dev @testing-library/user-event
	// simulates real user interactions in the browse
	// examples: mouse down, focus, mouse up, click, related keyboard events, async delays (like real typing)

npm install --save-dev @vitest/coverage-v8
npx vitest run --coverage
	// this is to generate a report of all the covered tests for components and services
	// will generate a "coverage" directory once you run the command
	// optional custom script to add: 
		"test:coverage": "vitest run --coverage"
	// add "coverage/" to the .gitignore file

npm init playwright@latest
	// a project scaffolding command
	// Playwright is an end-to-end (E2E) testing framework.
	// Tests run in real browsers; Verifies frontend + backend together; Complements (does not replace) unit tests
	// Playwright verifies: Frontend UI, Backend API, Database, Cookies / localStorage, CORS, Authentication, Routing
	// example:
		await page.goto('/')
		await page.fill('input[name="username"]', 'mluukkai')
		await page.fill('input[name="password"]', 'salainen')
		await page.click('button:text("login")')
		await expect(page.getByText('logged in')).toBeVisible()
	// Unlike the backend tests or unit tests done on the React front-end, E2E tests do not need to be located in the same npm project where the code 	is. Make a completely separate project for the E2E tests with the npm init command. Then install Playwright by running in the new project 	directory the command: npm init playwright@latest

	// useful custom scripts:
	    "test": "playwright test",
	    "test:ui": "playwright test --ui",
	    "test:report": "playwright show-report"

	// Playwright tests assume that the system under test is running when the tests are executed. Unlike, for example, backend integration tests, 	Playwright tests do not start the system under test during testing.
	Make an npm script for the backend, which will enable it to be started in testing mode, i.e. so that NODE_ENV gets the value test:
		"start:test": "cross-env NODE_ENV=test node --watch index.js"
	// "playwright test --ui" is to run tests in playwright's UI mode, pretty useful

// EDIT playwright.config.js FOR YOUR CONVIENIENCE
  timeout: 3000,
  fullyParallel: false,
  workers: 1,
	// specified that all tests be executed one at a time. With the default configuration, the execution happens in parallel, and since our tests use 	a database, parallel execution causes problems.

npx playwright test --grep "Login form is shown"
	// to run a single e2e test, need to provide the test name description
	// OR YOU CAN JUST USE THE PLAYWRIGHT'S UI WHEN YOU EXECUTE IT WITH THE SCRIPT  "test:ui": "playwright test --ui"

npx playwright test --grep "Login form is shown" --debug
	// This command runs problematic tests in debug mode
	// Playwright-inspector shows the progress of the tests step by step. The arrow-dot button at the top takes the tests one step further. The 	elements found by the locators and the interaction with the browser are visualized in the browser:
	// Playwright-inspector shows the progress of the tests step by step. The arrow-dot button at the top takes the tests one step further. The 	elements found by the locators and the interaction with the browser are visualized in the browser:

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 6 Advanced state management _______________________________________________________________________________________________________________________

npm install redux // APPERENTLY ITS DEPRECATED, DON'T USE

npm install react-redux
	// lets React components talk to a Redux store.
	// Without react-redux, you‚Äôd have to: 
		- Manually subscribe to the store, 
		- Manually read state, 
		- Manually dispatch actions, 
		- Manually force re-renders

npm install @reduxjs/toolkit
	// almost always used together with react-redux
	// an official abstraction layer on top of Redux that:
		- Reduces boilerplate
		- Enforces best practices
		- Makes Redux easier and safer
		- Includes the most common Redux tools by default

npm install @tanstack/react-query
	// a library for managing server state in React.
	// React Query ‚Üí server state
	// Server state = API data, DB data, cached responses
	// What it does for you (core features)
		1Ô∏è‚É£ Fetching data (without useEffect)
				2Ô∏è‚É£ Automatic caching üß†
		3Ô∏è‚É£ Background refetching & freshness
				4Ô∏è‚É£ Mutations (POST / PUT / DELETE)
				5Ô∏è‚É£ Built-in loading & error states

//NOTE TO SELF:
| Pattern           | When to use                       |
| ----------------- | --------------------------------- |
| `useState`        | Simple, local state               |
| `useReducer`      | Complex local state               |
| Context + Reducer | App-wide state, small/medium apps |
| Redux Toolkit     | Large apps, heavy logic           |
| React Query       | Server state                      |

React Query is a server-state library, responsible for managing asynchronous operations between your server and client.
Redux, etc. are client-state libraries that can be used to store asynchronous data, albeit inefficiently when compared to a tool like React Query

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 7 React router, custom hooks, styling app with CSS and webpack_____________________________________________________________________________________

npm install react-router-dom
	// enables routing in React SPAs
	// Maps URLs to components
	// Prevents page reloads
	// Handles navigation, params, redirects

npm outdated --depth 0
	// to check how up-to-date your dependencies are

npm install -g npm-check-updates
	// dependencies can be brought up to date by updating the file package.json using this library
	// -g means it is going to be installed globally
	// to run the library you use these commands:
		npm-check-updates
		ncu -u
		npm install

npm audit
	// used to check the security of dependencies. 
	// It compares the version numbers of the dependencies in your application to a list of the version numbers of dependencies containing known 	security threats in a centralized error database.
	// then run the command:
		npm audit fix
	// by default, audit fix does not update dependencies if their major version number has increased. Updating these dependencies could lead to the 	whole application breaking down.

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 8 GraphQL__________________________________________________________________________________________________________________________________________

NOTE: Apollo can be either used as a standalone server, or it can be hybridized with other Node.js servers (Express, NestJS, Fastify...)

npm install @apollo/server graphql
	// apollo server = The server framework that runs GraphQL over HTTP (Wraps the graphql engine)
	// Think of it as: The web server layer + developer-friendly wrapper around GraphQL.

NOTE: When Apollo server is run in development mode, the page http://localhost:PORT# (the port # that was defined) takes us to GraphOS Studio Explorer.

npm install @apollo/client graphql
	// frontend library used to connect your app to a GraphQL server
	// It lets your React (or React Native / Expo / Next.js) app:
		Send GraphQL queries
		Send mutations
		Cache results
		Manage loading & error states
		Automatically update UI when data changes

NOTE:
"Apollo Client and the applications state
In our example, management of the applications state has mostly become the responsibility of Apollo Client. This is quite a typical solution for GraphQL applications. Our example uses the state of the React components only to manage the state of a form and to show error notifications. As a result, it could be that there are no justifiable reasons to use Redux to manage application state when using GraphQL."

npm install @as-integrations/express5
	// the official integration layer that connects Apollo Server v4+ to Express 5
	Without it, Apollo Server can‚Äôt plug into Express.
	// Since Apollo Server 3.0+ doesn't support subscriptions anymore, you need to integrate Apollo Server into another framework does support it 
	(such as Express or Fastify)
	// It provides:
		expressMiddleware()
		Proper request/response bridging
		Context handling
		Compatibility with Express 5‚Äôs API
	// You need it if:
		You are using Apollo Server v4+
		You want to run it inside Express 5
		You want REST + GraphQL on the same server
		You need custom middleware (auth, logging, cookies, etc.)
	// You do NOT need it if:
		You‚Äôre using startStandaloneServer

npm install graphql-ws ws @graphql-tools/schema
	// these three libraries usually show up when you're implementing GraphQL subscriptions (real-time features) manually.
	// you‚Äôre preparing your server to support:
		WebSockets
		Real-time GraphQL subscriptions
		Custom schema creation
	// graphql-ws: Implements the GraphQL over WebSocket protocol. It allows clients to:
		Open a persistent WebSocket connection
		Subscribe to real-time GraphQL events
		Receive pushed updates from the server
	// ws: WebSocket server implementation for Node.js. ws provides the actual:
		WebSocket server
		TCP handling
		Low-level socket management
	// @graphql-tools/schema: Creates an executable GraphQL schema from:
		Type definitions (SDL)
		Resolver functions
		It‚Äôs used when you aren‚Äôt relying on a framework (like NestJS) to generate the schema for you.
	// When you build a custom GraphQL server (especially with Apollo Server v4):
	You need:
		@graphql-tools/schema ‚Üí create the schema
		ws ‚Üí create WebSocket server
		graphql-ws ‚Üí run subscriptions over that WebSocket
	Together they enable:
		GraphQL Queries (HTTP)
	GraphQL Mutations (HTTP)
	GraphQL Subscriptions (WebSocket)

npm install graphql-subscriptions
	// It provides a simple Publish/Subscribe (PubSub) system for GraphQL subscriptions.
	// It helps your server:
		Publish events when something happens (e.g., message created)
		Notify all subscribed clients
		Wire those events into GraphQL subscription resolvers
		- It does not create WebSockets.
		- It does not run the server.
		- It only manages event broadcasting.
	üéØ Important Limitation
	The default PubSub implementation is 'In-memory only'
	Meaning:
		Works only within one server instance
		Does NOT scale horizontally
		Not production-safe for distributed systems
	In real production systems, people replace the default PubSub with:
		Redis PubSub
		Kafka
		RabbitMQ
		Google PubSub
		AWS SNS/SQS
	Apollo even recommends Redis for scaling subscriptions, AKA:
		'graphql-redis-subscriptions'

NOTE: 
- "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil."
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 9 TypeScript_______________________________________________________________________________________________________________________________________


** WATCH THIS VIDEO AFTER YOU FINISH PART 9 TypeScript: Next js Tutorial for Beginners | Nextjs 13 (App Router) with TypeScript - left off at:
https://www.youtube.com/watch?v=ZVnjOPwW4ZA
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 10 React Native____________________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 11 CI/CD___________________________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 12 Containers______________________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 13 Using relational databases______________________________________________________________________________________________________________________

