Part 1 Introduction to React____________________________________________________________________________________________________________________________

npm create vite@latest 
	// to create a new React frontend project

//IMPORTANT!! When cloning an external project inside of an existing project, make sure to go inside of the newly cloned repo and delete the 	existing .git file with the commands:
		git clone <new project>
		cd <new project>
		rm -rf .git // MUST REMOVE .git FILE WHEN CLONING INTO EXISITNG PROJECT!!! 
		npm install
		"npm start" or "npm run dev"

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 2 Communicating with server________________________________________________________________________________________________________________________

npx json-server --port 3001 db.json 
	//runs a local fake REST API on port 3001 using data from db.json, need to have db.json implemented
npm install json-server --save-dev
	// to start the json server, add this script to package.json
		- "server": "json-server -p 3001 db.json"
	// then you run the server with the command:
		- npm run server

npm install axios 
	//Axios is a library that simplifies making HTTP requests and handling responses in JavaScript applications. Used mostly in frontend

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 3 Programming a server with NodeJS and Express ____________________________________________________________________________________________________

npm init
	// creates a package.json file, which defines your project and enables npm to manage dependencies and scripts.

npm install express 
	// for backend server

npm update
	// updates the dependencies of a project

npm install
	// Likewise, if we start working on the project on another computer, we can install all up-to-date dependencies of the project defined in 	package.json by running this command in the project's root directory

node --watch index.js
	// runs your Express server and automatically restarts it whenever your code changes
	// typically found as a script -> "dev": "node --watch index.js"
	// Does not: Hot-reload without restart, preserve server state, replace frontend hot module reload
	// although the server restarts automatically, you still need to refresh the browser

*.rest
	// once you have the plugin "REST client" installed, you can create .rest files to test out HTTP requests in the backend
		// ex: GET http://localhost:3001/api/notes
	// .rest files are typically placed in a "requests" directory in the root folder

npm install cors
	// We can allow requests from other origins by using Node's cors middleware in the backend
	// even with proxy in place, you still want cors for production builds

// creating a proxy for the frontend in vite.config.js when in dev mode 
	// example:
		export default defineConfig({
		  plugins: [react()],
		  server: {
		    proxy: {
		      '/api': {
		        target: 'http://localhost:3003',
		        changeOrigin: true
		      }
		    }
		  }
		})

npm run build 
	// to create a production build of your application (used in the frontend with vite)

// useful custom scripts for backend: (SIDE NOTE: you sure that these scripts will work in PowerShell?????)
    "build:ui": "rm -rf dist && cd ../frontend && npm run build && cp -r dist ../backend",
    "deploy:full": "npm run build:ui && git add . && git commit -m uibuild && git push",

npm install mongoose 
	// install in the backend

npm install eslint @eslint/js --save-dev
	// analyzes your JavaScript for bugs and bad patterns, and @eslint/js provides a set of recommended rules, both used only during development.
npx eslint --init
	// to initialize a default ESlint configuration
npm install --save-dev @stylistic/eslint-plugin
	// to create formatting rules so you can enforce consistent code style without affecting program behavior (did not implement in project)
npx eslint index.js (CREATE CUSTOM SCRIPT TO USE)
	// to inspect and validate a file
	// recommended to create a custom script for it:
		// "lint": "eslint ."
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 4 Testing Express servers, user administration_____________________________________________________________________________________________________

npm install cross-env
	// lets you define environment variables in npm scripts in a way that works on all operating systems.
	// This is so that we can set "NODE_ENV" to different modes in the scripts
	// Example:
		"scripts": {
			"test": "cross-env NODE_ENV=test node --test",
			"start": "cross-env NODE_ENV=production node index.js",
			"dev": "cross-env NODE_ENV=development node --watch index.js" }
	// NODE_ENV lets your app and tools know whether they‚Äôre running in development, testing, or production so they can change behavior safely and 	efficiently.

npm install --save-dev supertest
	// a library for testing HTTP APIs (especially Express apps) without starting a real server.
	// Think of Supertest as Postman, but inside your test file and fully automated.

npm test -- tests/blog_api.test.js
	// executes tests specified by route argument

npm test -- --test-only
	// only the only marked tests are executed
	// Example:
		test.only('all notes are returned', async () => {
	// IMPORTANT NOTE!
	// IN ORDER FOR THIS COMMAND TO WORK YOU MUST INCLUDE "cross-env NODE_ENV=test"
	// BETTER YET, CREATE A CUSTOM SCRIPT TO RUN IT:
		"test:only": "cross-env NODE_ENV=test node --test --test-only"

npm test -- --test-name-pattern="a specific note is within the returned notes" // COMMAND DOES NOT WORK AS INTENDED!!!!!
	// COMMAND DOES NOT WORK AS INTENDED!!!!!
	// run tests with a specific name
	// The provided argument can refer to the name of the test or the describe block
	//It can also contain just a part of the name. The following command will run all of the tests that contain notes in their name:
		npm run test -- --test-name-pattern="notes"
	// COMMAND DOES NOT WORK AS INTENDED!!!!!
	// IMPORTANT NOTE!
	// IN ORDER FOR THIS COMMAND TO WORK YOU MUST INCLUDE "cross-env NODE_ENV=test"
	// BETTER YET, CREATE A CUSTOM SCRIPT TO RUN IT:
		"test:pattern": "cross-env NODE_ENV=test node --test --test-name-pattern"
	// THEN RUN: 
		npm run test:pattern "a specific blog can be viewed"

npm install bcrypt
	// a library used to securely hash passwords before storing them in a database
	// Never use bcrypt in the frontend

npm install jsonwebtoken
	//(often called JWT) lets your backend server issue & verify signed tokens so users stay authenticated without sending passwords on every request
	// Important: JWT payload is readable, so never store passwords or secrets in it.

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 5 Testing React apps_______________________________________________________________________________________________________________________________

npm install --save-dev vitest jsdom
	// Vitest runs tests (Provides test utilities: test, it, describe, expect)
	// jsdom pretends to be the browser (Simulates: window, document, HTMLElement, events, localStorage)
	// Together ‚Üí test React in Node
	// add this custom script:
		"test": "vitest run" 

npm install --save-dev @testing-library/react @testing-library/jest-dom
	// @testing-library/react ‚Äî render & interact with React components
		// Renders React components into a DOM (via jsdom)
		// Lets you query the UI the way a user would:
			text on the screen
			labels
			roles (buttons, headings, inputs)
		// Simulates user interactions
		// example:
			test('renders app title', () => {
			  render(<App />)
		  expect(screen.getByText('Blog list')).toBeInTheDocument()
			})
	// @testing-library/jest-dom ‚Äî better assertions for the DOM 
		// examples:
			expect(button).toBeInTheDocument()
			expect(button).toBeDisabled()
			expect(button).toHaveTextContent('Save')

npm install --save-dev @testing-library/user-event
	// simulates real user interactions in the browse
	// examples: mouse down, focus, mouse up, click, related keyboard events, async delays (like real typing)

npm install --save-dev @vitest/coverage-v8
npx vitest run --coverage
	// this is to generate a report of all the covered tests for components and services
	// will generate a "coverage" directory once you run the command
	// optional custom script to add: 
		"test:coverage": "vitest run --coverage"
	// add "coverage/" to the .gitignore file

npm init playwright@latest
	// a project scaffolding command
	// Playwright is an end-to-end (E2E) testing framework.
	// Tests run in real browsers; Verifies frontend + backend together; Complements (does not replace) unit tests
	// Playwright verifies: Frontend UI, Backend API, Database, Cookies / localStorage, CORS, Authentication, Routing
	// example:
		await page.goto('/')
		await page.fill('input[name="username"]', 'mluukkai')
		await page.fill('input[name="password"]', 'salainen')
		await page.click('button:text("login")')
		await expect(page.getByText('logged in')).toBeVisible()
	// Unlike the backend tests or unit tests done on the React front-end, E2E tests do not need to be located in the same npm project where the code 	is. Make a completely separate project for the E2E tests with the npm init command. Then install Playwright by running in the new project 	directory the command: npm init playwright@latest

	// useful custom scripts:
	    "test": "playwright test",
	    "test:ui": "playwright test --ui",
	    "test:report": "playwright show-report"

	// Playwright tests assume that the system under test is running when the tests are executed. Unlike, for example, backend integration tests, 	Playwright tests do not start the system under test during testing.
	Make an npm script for the backend, which will enable it to be started in testing mode, i.e. so that NODE_ENV gets the value test:
		"start:test": "cross-env NODE_ENV=test node --watch index.js"
	// "playwright test --ui" is to run tests in playwright's UI mode, pretty useful

// EDIT playwright.config.js FOR YOUR CONVIENIENCE
  timeout: 3000,
  fullyParallel: false,
  workers: 1,
	// specified that all tests be executed one at a time. With the default configuration, the execution happens in parallel, and since our tests use 	a database, parallel execution causes problems.

npx playwright test --grep "Login form is shown"
	// to run a single e2e test, need to provide the test name description
	// OR YOU CAN JUST USE THE PLAYWRIGHT'S UI WHEN YOU EXECUTE IT WITH THE SCRIPT  "test:ui": "playwright test --ui"

npx playwright test --grep "Login form is shown" --debug
	// This command runs problematic tests in debug mode
	// Playwright-inspector shows the progress of the tests step by step. The arrow-dot button at the top takes the tests one step further. The 	elements found by the locators and the interaction with the browser are visualized in the browser:
	// Playwright-inspector shows the progress of the tests step by step. The arrow-dot button at the top takes the tests one step further. The 	elements found by the locators and the interaction with the browser are visualized in the browser:

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 6 Advanced state management _______________________________________________________________________________________________________________________

npm install redux // APPERENTLY ITS DEPRECATED, DON'T USE

npm install react-redux
	// lets React components talk to a Redux store.
	// Without react-redux, you‚Äôd have to: 
		- Manually subscribe to the store, 
		- Manually read state, 
		- Manually dispatch actions, 
		- Manually force re-renders

npm install @reduxjs/toolkit
	// almost always used together with react-redux
	// an official abstraction layer on top of Redux that:
		- Reduces boilerplate
		- Enforces best practices
		- Makes Redux easier and safer
		- Includes the most common Redux tools by default

npm install @tanstack/react-query
	// a library for managing server state in React.
	// React Query ‚Üí server state
	// Server state = API data, DB data, cached responses
	// What it does for you (core features)
		1Ô∏è‚É£ Fetching data (without useEffect)
				2Ô∏è‚É£ Automatic caching üß†
		3Ô∏è‚É£ Background refetching & freshness
				4Ô∏è‚É£ Mutations (POST / PUT / DELETE)
				5Ô∏è‚É£ Built-in loading & error states

//NOTE TO SELF:
| Pattern           | When to use                       |
| ----------------- | --------------------------------- |
| `useState`        | Simple, local state               |
| `useReducer`      | Complex local state               |
| Context + Reducer | App-wide state, small/medium apps |
| Redux Toolkit     | Large apps, heavy logic           |
| React Query       | Server state                      |

React Query is a server-state library, responsible for managing asynchronous operations between your server and client.
Redux, etc. are client-state libraries that can be used to store asynchronous data, albeit inefficiently when compared to a tool like React Query

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 7 React router, custom hooks, styling app with CSS and webpack_____________________________________________________________________________________

npm install react-router-dom
	// enables routing in React SPAs
	// Maps URLs to components
	// Prevents page reloads
	// Handles navigation, params, redirects

npm outdated --depth 0
	// to check how up-to-date your dependencies are

npm install -g npm-check-updates
	// dependencies can be brought up to date by updating the file package.json using this library
	// -g means it is going to be installed globally
	// to run the library you use these commands:
		npm-check-updates
		ncu -u
		npm install

npm audit
	// used to check the security of dependencies. 
	// It compares the version numbers of the dependencies in your application to a list of the version numbers of dependencies containing known 	security threats in a centralized error database.
	// then run the command:
		npm audit fix
	// by default, audit fix does not update dependencies if their major version number has increased. Updating these dependencies could lead to the 	whole application breaking down.

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 8 GraphQL__________________________________________________________________________________________________________________________________________

NOTE: Apollo can be either used as a standalone server, or it can be hybridized with other Node.js servers (Express, NestJS, Fastify...)

npm install @apollo/server graphql
	// apollo server = The server framework that runs GraphQL over HTTP (Wraps the graphql engine)
	// Think of it as: The web server layer + developer-friendly wrapper around GraphQL.

NOTE: When Apollo server is run in development mode, the page http://localhost:PORT# (the port # that was defined) takes us to GraphOS Studio Explorer.

npm install @apollo/client graphql
	// frontend library used to connect your app to a GraphQL server
	// It lets your React (or React Native / Expo / Next.js) app:
		Send GraphQL queries
		Send mutations
		Cache results
		Manage loading & error states
		Automatically update UI when data changes

NOTE:
"Apollo Client and the applications state
In our example, management of the applications state has mostly become the responsibility of Apollo Client. This is quite a typical solution for GraphQL applications. Our example uses the state of the React components only to manage the state of a form and to show error notifications. As a result, it could be that there are no justifiable reasons to use Redux to manage application state when using GraphQL."

npm install @as-integrations/express5
	// the official integration layer that connects Apollo Server v4+ to Express 5
	Without it, Apollo Server can‚Äôt plug into Express.
	// Since Apollo Server 3.0+ doesn't support subscriptions anymore, you need to integrate Apollo Server into another framework does support it 
	(such as Express or Fastify)
	// It provides:
		expressMiddleware()
		Proper request/response bridging
		Context handling
		Compatibility with Express 5‚Äôs API
	// You need it if:
		You are using Apollo Server v4+
		You want to run it inside Express 5
		You want REST + GraphQL on the same server
		You need custom middleware (auth, logging, cookies, etc.)
	// You do NOT need it if:
		You‚Äôre using startStandaloneServer

npm install graphql-ws ws @graphql-tools/schema
	// these three libraries usually show up when you're implementing GraphQL subscriptions (real-time features) manually.
	// you‚Äôre preparing your server to support:
		WebSockets
		Real-time GraphQL subscriptions
		Custom schema creation
	// graphql-ws: Implements the GraphQL over WebSocket protocol. It allows clients to:
		Open a persistent WebSocket connection
		Subscribe to real-time GraphQL events
		Receive pushed updates from the server
	// ws: WebSocket server implementation for Node.js. ws provides the actual:
		WebSocket server
		TCP handling
		Low-level socket management
	// @graphql-tools/schema: Creates an executable GraphQL schema from:
		Type definitions (SDL)
		Resolver functions
		It‚Äôs used when you aren‚Äôt relying on a framework (like NestJS) to generate the schema for you.
	// When you build a custom GraphQL server (especially with Apollo Server v4):
	You need:
		@graphql-tools/schema ‚Üí create the schema
		ws ‚Üí create WebSocket server
		graphql-ws ‚Üí run subscriptions over that WebSocket
	Together they enable:
		GraphQL Queries (HTTP)
	GraphQL Mutations (HTTP)
	GraphQL Subscriptions (WebSocket)

npm install graphql-subscriptions
	// It provides a simple Publish/Subscribe (PubSub) system for GraphQL subscriptions.
	// It helps your server:
		Publish events when something happens (e.g., message created)
		Notify all subscribed clients
		Wire those events into GraphQL subscription resolvers
		- It does not create WebSockets.
		- It does not run the server.
		- It only manages event broadcasting.
	üéØ Important Limitation
	The default PubSub implementation is 'In-memory only'
	Meaning:
		Works only within one server instance
		Does NOT scale horizontally
		Not production-safe for distributed systems
	In real production systems, people replace the default PubSub with:
		Redis PubSub
		Kafka
		RabbitMQ
		Google PubSub
		AWS SNS/SQS
	Apollo even recommends Redis for scaling subscriptions, AKA:
		'graphql-redis-subscriptions'

NOTE: 
- "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil."


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 9 TypeScript_______________________________________________________________________________________________________________________________________
npm install --save-dev ts-node typescript
	// ts-node allows you to run TypeScript files directly, without compiling them first.
	// add this costume script to your package.json:
		"ts-node": "ts-node"
	// NOTE: IT IS NOT ADVISABLE TO USE ts-node IN OFFICIAL APPLICATIONS
	 it is advisable to use the official TypeScript compiler that comes with the typescript npm-package. The official compiler generates and packages 	 JavaScript files from the .ts files so that the built production version won't contain any TypeScript code anymore. 

npm install --save-dev @types/express
	// need to include the types for all the packages you are going to be using with typescript
	// Make sure to install them in the devDependencies section
	// When installing new types into your project, you may need to reopen the file in the editor to get VS Code in sync.

npm install --save-dev ts-node-dev
	// used only in the backend!
	// enables auto-reloading on the browser when you make changes to your code
	// add a custom script similar to this once you add this library:
		"dev": "ts-node-dev src/index.ts"

npm install --save-dev @eslint/js @types/eslint__js typescript-eslint
	// @eslint/js:
		Official ESLint JS rule configs
	// typescript-eslint: This is the modern TypeScript integration for ESLint.
		It combines what used to be:
			@typescript-eslint/parser
			@typescript-eslint/eslint-plugin
	// @types/eslint__js:
		It provides TypeScript type definitions for @eslint/js.

npm install --save-dev @stylistic/eslint-plugin
	// Provides formatting/style rules removed from ESLint core
	// If you're using Prettier ‚Üí you probably don‚Äôt need this.

 npm run tsc -- --init
	// this will generate a tsconfig.json file for us
	// Note: we must have this custom script set up: 
		"tsc": "tsc"

npm run tsc
	// creates a production build by running the TypeScript compiler
	// the directory "build" should automatically be generated (or what ever directory is specified in your tsconfig.json file)
	// add this custom script once you have the production build:
		"start": "node build/index.js"
			// This will start your production mode build

npm install zod
	// Zod is a TypeScript-first schema validation library.
	// Its purpose:
		‚úÖ Validate runtime data
		‚úÖ Infer static TypeScript types from schemas
		‚úÖ Keep runtime validation and compile-time types in sync
	// TypeScript types:
		Only exist at compile time
		Do NOT validate data at runtime
	// This does NOT protect you from:
		API requests
		JSON input
		Database responses
		Form submissions
		Because TypeScript disappears at runtime.

"The more code you read, the better you will be at understanding it. 
You will most likely read far more code than you are going to produce throughout your life."


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 10 React Native____________________________________________________________________________________________________________________________________
NOTE: Using npx expo install (rather than npm install) is recommended for Expo packages because it automatically resolves the version compatible with your 	Expo SDK version (53 in your case for this tutorial).

npx create-expo-app rate-repository-app --template expo-template-blank@sdk-50
	// NOTE: NOT RECOMMENDED TO USE THIS SPECIFIC TEMPLATE FOR NEW PROJECTS!!! (refer to below 2 commands)
	// create-expo-app is the official project scaffolding tool from Expo.
	// expo-template-blank: This tells Expo to use the minimal starter template, which includes:
		- A basic App.js
		- No navigation
		- No extra libraries
		- Clean starting point
	// @sdk-50: SDK 50 ensures:
		- You‚Äôre using the correct environment for that version
		- Compatibility with course material (very common in university assignments)
		- Stability across team members
	// after you run the above command, you'll be able to run these commands below:
		- npm run android
		- npm run ios # you need to use macOS to build the iOS project - use the Expo app if you need to do iOS development without a Mac
		- npm run web
		- npm start  // this will just prompt you to choose between many different options such as:
			‚Ä∫ Press a ‚îÇ open Android
			‚Ä∫ Press w ‚îÇ open web
			‚Ä∫ Press j ‚îÇ open debugger	etc...

npx create-expo-app social-game
	// Gives you a minimal app with TypeScript (by default in newer versions).

npx create-expo-app social-game --template tabs
	// This gives you:
		- Navigation pre-configured
	 	- Multiple screens
		- A more realistic app structure

npx expo install react-native-web@~0.19.6 react-dom@18.2.0 @expo/metro-runtime@~3.1.1
	// react-native-web: Allows React Native components to render in a web browser.
		Normally: View, Text, ScrollView are mobile components.
	// react-dom: Renders React components into the browser DOM.
	// @expo/metro-runtime: Makes Expo + Metro work in browser
	// NOTE: IF YOU ARE GOING TO USE NEXT.JS FOR THE WEB APP, YOU DON'T NEED ANY OF THESE LIBRARIES IN EXPO

Note: To open Developer menu: Shake your device (or press Ctrl + m on Android emulator)

npm install --save-dev eslint @babel/eslint-parser eslint-plugin-react eslint-plugin-react-native

npx react-devtools
	// It‚Äôs a standalone debugging tool for react applications.
		It allows you to:
		-Inspect your component tree
		-View props
		-View state
		-Track hooks
		-See context values
		-Detect unnecessary re-renders
	// It‚Äôs essentially a visual debugger for React components.
	// might have to use the command "adb reverse tcp:8097 tcp:8097" to get the react-devtools to connect to your emulator instance

npx expo install expo-constants
	// expo-constants provides system-level information about the app and device at runtime.
	// It gives you read-only values like:
		App version
		App name
		Bundle ID
		Device info
		Platform info
		Execution environment (Expo Go, dev client, standalone build)
	// Example: paddingTop: Constants.statusBarHeight
	// Using npx expo install (rather than npm install) is recommended for Expo packages because it automatically resolves the version compatible with 	your Expo SDK version (53 in your case).
	
npx expo install react-router-native

npx expo install yup formik
	// Formik ‚Äî Form State Management: Makes handling forms in React much easier. Without Formik, you‚Äôd manually manage:
		useState for each input
		onChange handlers
		onBlur
		errors
		touched
		Submission logic
		Validation triggering
	// Yup ‚Äî Schema-Based Validation: Defines structured validation rules for objects.
	// Why They‚Äôre Installed Together: Formik supports Yup natively. You pass the schema to Formik

________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 11 CI/CD___________________________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 12 Containers______________________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________
Part 13 Using relational databases______________________________________________________________________________________________________________________








** WATCH THIS VIDEO AFTER YOU FINISH PART 9 TypeScript: 
Next js Tutorial for Beginners | Nextjs 13 (App Router) with TypeScript - left off at:
https://www.youtube.com/watch?v=ZVnjOPwW4ZA